//
//
//
//
///////////////////////  M o t h e r F u n c t i o n s  ///////////////////////

// Calculate the depth of an object
@function depth($object) {
  $count: 1;
  // if map - calculate depth
	@if is-map($object) {
	  @each $key, $value in $object {
	    @if is-map($value) { $count: max(depth($value) + 1, $count); }
	  }
  }
  // if list - look for map to calculate depth
  @else if is-list($object) {
	  @each $value in $object {
	    @if is-map($value) { $count: max(depth($value) + 1, $count); }
	  }
  }
  // output
  @return $count;
}

// Check a list for an item
@function has-item($list, $item) {
  @each $listee in $list {
    @if $listee == $item { @return true; }
  } @return false;
}

// Check a list for multiple items
@function has-items($list, $items) {
  @each $item in $items {
    @if not has-item($list, $item) { @return false; }
  } @return true;
}

// Checks a list for a joint word
@function has-joint($list) {
  @each $listee in $list {
    @if is-joint($listee) { @return true; }
  } @return false;
}
// Units handler
@function its($input, $outUnits: nest-get(fether, units default)) {
  $inUnits: null;
  $modifier: null;
  // set rem base
  $base: strip(nest-get(fether, units base));
  // list accepted units as modifiers
  $type: 1em, 1rem, 1ex, 1ch, 1%, 1vw, 1vh, 1vmin, 1vmax, 1px, 1cm, 1mm, 1in, 1pt, 1pc, 1dp;
  // map converters
  $con: (px: 96, pt: 72, pc: 6, mm: 25.4, cm: 2.54, in: 1, em: $base, rem: $base,);  // list units that can be converted
  // list units that can be converted
  $canCon: map-keys($con);
  // if joints - set input, set outbound units
  @if has-joint($input) {
    $input: joint-mapper($input);
    $outUnits: map-get($input, 2);
    $input: map-get($input, 1);
  }
  // set outbound modifier
  @each $item in $type {
    $unit: unit($item);
    @if $unit == $outUnits { $modifier: $item; }
  }
  // if the outbound units are not recognized
  @if not $modifier {
    @warn 'The units "#{$outUnits}" are not recognized by the its() function, defaulted to "px".';
    $modifier: 1px;
  }
  // validate number
  @if is-number($input) {
    // if input has units - strip input - set incoming units
    @if not unitless($input) {
      $inUnits: unit($input);
      $inUnits: unquote($inUnits);
      $input: strip($input);
    // if unitless input, set incoming units to pixels
    } @else { $inUnits: px; }
    // if the incoming value is convertable
    @if has-item($canCon, $inUnits) {
      // set incoming calculator
      $calc: map-get($con, $inUnits);
      // convert incoming value to pixels
      $input: $input * (96 / $calc);
    }
    //
    // begin outbound unit conversion
    //
    @if has-item($canCon, $outUnits) {
      // set outgoing calculator
      $calc: map-get($con, $outUnits);
      // set outgoing value
      $input: $input / (96 / $calc);
    }
    // add outgoing units
    $input: $input * $modifier;
  }
  // warn if no number found
  @else {
    @warn 'No number value found for its() input: "#{$input}".';
    @return null;
  }
  // output
  @return $input;
}

// Returns a numbered map of all entries found that are separated by joint words
@function joint-mapper($input) {
  $listing: null; $mapping: null; $merger: null;
  $index: 0;
  $subindex: 0;
  $conCnt: 0;
  // filter input
  @each $item in $input {
    $index: $index + 1;
    // if find a joint
    @if is-joint($item) or $index == length($input) {
      @if $index == length($input) and $listing { $listing: append($listing, $item); }
      @else if $index == length($input) { $listing: $item; }
      $conCnt: $conCnt + 1;
      $merger: ($conCnt : $listing, );
      // map structuring
      @if $mapping { $mapping: map-merge($mapping, $merger); }
      @else { $mapping: $merger; }
      $listing: null;
    }
    // if no joint, check for list
    @else if is-list($item) {
      @each $subitem in $item {
        $subindex: $subindex + 1;
        @if $subindex == 1 { $listing: $subitem; }
        @else { $listing: append($listing, $subitem); }
      }
    }
    // create current listing to be put into map once joint is found
    @else {
      @if $listing { $listing: append($listing, $item);}
      @else { $listing: $item; }
    }
  // output
  } @return $mapping;
}

// Checks specific object types
@function is-bool($input)        { @return type-of($input) == bool; }
@function is-color($input)       { @return type-of($input) == color; }
@function is-list($input)        { @return type-of($input) == list; }
@function is-map($input)         { @return type-of($input) == map; }
@function is-number($input)      { @return type-of($input) == number; }
@function is-string($input)      { @return type-of($input) == string; }
@function is-angle($input)       { @return is-num($input) and index( 'deg' 'grad' 'rad' 'turn', unit($input) ) != null; }
@function is-integer($input)     { @return is-num($input) and round($input) == $input; }
@function is-percent($input)     { @return is-num($input) and unit($input) == '%'; }
@function is-resolution($input)  { @return is-num($input) and index( 'dpcm' 'dpi' 'dppx', unit($input) ) != null; }
@function is-time($input)        { @return is-num($input) and index( 'ms' 's', unit($input) ) != null; }
@function is-abs-length($input)  { @return is-num($input) and index( 'cm' 'in' 'mm' 'pc' 'pt' 'px', unit($input) ) != null; }
@function is-rel-length($input)  { @return is-num($input) and index( 'ch' 'em' 'ex' 'rem', unit($input) ) != null; }
@function is-rel-percent($input) { @return is-num($input) and index( '%' 'vh' 'vmax' 'vmin' 'vw', unit($input) ) != null; }
@function is-rel-view($input)    { @return is-num($input) and index( 'vh' 'vmax' 'vmin' 'vw', unit($input) ) != null; }
@function is-rel($input)         { @return is-rel-length($input) or is-rel-percent($input); }
@function is-relative($input)    { @return is-rel-length($input) or is-rel-percent($input); }
@function is-length($input)      { @return is-rel-length($input) or is-abs-length($input); }
@function is-position($input)    { @return index( 'top' 'right' 'bottom' 'left' 'center' 'middle', $input) != null; }
@function is-joint($input)       { @return index( '^' 'make' 'now' 'with' 'and' 'to' 'for' 'by' 'of' 'from' 'then', $input) != null; }
// Check if a map has another map (nest)ed inside
@function is-nest($input) {
  @if is-map($input) {
    @each $key, $value in $input {
      @if is-map($value) { @return true; }
    }
  } @return false;
}

// Check if the input is a keyword that is associated with a nest.
// Returns associated nest if found, otherwise passes input through.
@function nest-filter($input) {
  @if $input == 'fether' { $input: $fether--nest; }
  @else if $input == 'break' { $input: nest-get($fether--nest, breakpoint); }
  @else if $input == 'color' { $input: nest-get($fether--nest, color); }
  @else if $input == 'container' { $input: nest-get($fether--nest, container); }
  @else if $input == 'font' { $input: nest-get($fether--nest, font); }
  @else if $input == 'grid' { $input: nest-get($fether--nest, grid); }
  @else if $input == 'stack' { $input: nest-get($fether--nest, font stack); }
  @else if $input == 'style' { $input: nest-get($fether--nest, opacity style); }
  @else if $input == 'type' { $input: nest-get($fether--nest, type); }
  @return $input;
}

// Return map of all keys and values inside specified object (including nested)
@function nest-gather($nest, $keys: null) {
  $nest: $nest;
  $returnMap: null;
  // pull map to gather keys and values from
  @if $keys { $nest: nest-get($nest, $keys); }
  $depth: depth($nest);
  // collect all keys and values (including nested)
  @for $i from 1 through $depth {
    @each $key, $value in $nest {
      $mapKeys: map-keys($nest);
      $index: index($mapKeys, $key);
      @if not is-map($value) {
        $value: ( $key: $value );
        @if $index == 1 { $returnMap: $value; }
        @else { $returnMap: map-merge($returnMap, $value); }
      }
      @else if is-map($value) {
        @if $index == 1 and $i == 1 { $returnMap: $value; }
        @else { $returnMap: map-merge($returnMap, $value); }
        $returnMap: map-remove($returnMap, $key);
      }
    }
    @if $i == 1 { $nest: $returnMap; }
    @else { $nest: map-merge($nest, $returnMap); }
  }
  // output
  @return $nest;
}

// Get value of a nested key
@function nest-get($nest, $keys) {
  $nest: nest-filter($nest);
  @each $key in $keys {
    $nest: map-get($nest, $key);
  }
  @if not $nest { @warn 'Nothing found for nest-get() at keys: "#{$keys}"'; }
  @return $nest;
}

// Check a nest for key
@function nest-has-key($nest, $items) {
  $nest: nest-filter($nest);
  @each $key in $items {
    @if not map-has-key($nest, $key) { @return false; }
    @else { $nest: map-get($nest, $key); }
  } @return true;
}

// Replace value of a key or add a key with a value to a nest
@function nest-send($nest, $keys, $newValue) {
  $nest: nest-filter($nest);
  $maps: ($nest,);
  $output: null;
  @if length($keys) == 1 { @return map-merge($nest, ($keys: $newValue)); }
  @for $i from 1 through (length($keys) - 1) {
    $cKey: nth($keys, $i);
    $cMap: nth($maps, -1);
    $cGet: map-get($cMap, $cKey);
    $maps: append($maps, $cGet);
  }
  @for $i from length($maps) through 1 {
    $cMap: nth($maps, $i);
    $cKey: nth($keys, $i);
    $cVal: if($i == length($maps), $newValue, $output);
    $output: map-merge($cMap, ($cKey: $cVal));
  }
  @return $output;
}

// Calculate the power of a number
@function power($number, $power) {
  @if (is-num($number)) and (is-num($power)) {
    $output: 1 !default;
    @if $power >= 0 {
      @for $var from 1 through $power { $output: $output * $number; }
    } @else {
      @for $var from $power to 0 { $output: $output / $number; }
    }
    @return $output;
  }
  @else {
    @if not is-num($number) { @warn 'Unknown power() number: #{$number}'; }
    @if not is-num($power)  { @warn 'Unknown power() power: #{$power}'; }
  }
}

// Strip units from a number
@function strip($number) {
  @if is-num($number) {
    $output: $number / ($number * 0 + 1);
    @return $output;
  }
  @else { @warn 'Unknown strip() value: #{$number}'; }
}
